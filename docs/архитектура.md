# Архитектура

## Общие Концепции (Расширение на Генератор Акций)

Проект эволюционировал от "гороскопных скидок" к универсальному "генератору акций". Ключевые домены:
- **Promotion**: Акция с темой (theme, e.g., 'zodiac', 'harry-potter').
- **Segments**: Динамические сегменты (e.g., знаки зодиака, факультеты Поттера), заменяют horoscope для универсальности.
- **Identification**: Режим определения сегмента пользователя (questions с тестами или user_profile по данным профиля).
- **Slots**: Места для товаров селлеров (аукцион/фиксированная цена, привязка к сегментам).
- **Moderation**: Проверка заявок селлеров по стоп-факторам.
- **AI**: Генерация тем, сегментов, текстов, вопросов/деревьев ответов.

Статусы акций (promotion.status):
- NOT_READY
- READY_TO_START
- RUNNING
- PAUSED
- COMPLETED

Валидация готовности (NOT_READY → READY_TO_START): наличие сегментов, ценовой модели, дат, идентификации.

## Публичные Эндпоинты (Buyer)

`GET /promotions/current` - Получение текущей активной акции

```
@startuml
actor User

User -> PromotionController : GET /promotions/current
PromotionController -> PromotionService : getActivePromotion()
PromotionService -> PG : SELECT promotion WHERE status='RUNNING' AND date_from <= now() AND date_to >= now()
PG --> PromotionService : promotion

PromotionService -> SegmentService : getSegments(promoId)
SegmentService -> PG : SELECT * FROM segment WHERE promotion_id=promoId
PG --> SegmentService : segments

SegmentService --> PromotionService : segments
PromotionService --> PromotionController : promo
PromotionController --> User : {id, name, description, theme, status, date_from, date_to, segments: [{id,name,category_name}]}

@enduml
```

`GET /promotions/{promotionId}/segments/{segmentId}/products` - Получение продуктов сегмента (с фильтрами)

```
@startuml
actor User

User -> SegmentController : GET /promotions/{promotionId}/segments/{segmentId}/products (filters: category, onlyDiscounts, sort, page, per_page)
SegmentController -> SegmentService : getSegment(promoId, segmentId)
SegmentService -> PG : SELECT * FROM segment WHERE promoId AND segmentId
PG --> SegmentService : segment
SegmentService --> SegmentController : segment

SegmentController -> SlotService : getSlots(segmentId)
SlotService -> PG : SELECT FROM slot WHERE segment_id=segmentId AND status='occupied'
PG --> SlotService : slots
SlotService --> SegmentController : productIds

SegmentController -> ProductService : getProducts(ids, filters)
ProductService -> PG : SELECT * FROM product WHERE id IN (...) AND filters
PG --> ProductService : products

ProductService --> SegmentController : products
SegmentController --> User : {items:[{id,name,image,price,old_price,discount,badge}], total, page, per_page, completed:boolean}

@enduml
```

`POST /identification/start` - Запуск идентификации

```
@startuml
actor User

User -> IdentificationController : POST /identification/start {promotionId}
IdentificationController -> IdentificationService : startIdentification(promoId)
IdentificationService -> PG : SELECT identification_mode FROM promotion WHERE id=promoId
PG --> IdentificationService : mode

alt mode = 'questions'
IdentificationService -> PG : SELECT questions/options FROM test_question/test_option WHERE promotion_id=promoId
PG --> IdentificationService : test
end

IdentificationService --> IdentificationController : {method: 'questions'|'user_profile', test?: {questions:[{id,text,options:[{id,text,value}]}]}}
IdentificationController --> User : response

@enduml
```

`POST /identification/answer` - Ответ на вопрос теста

```
@startuml
actor User

User -> IdentificationController : POST /identification/answer {promotionId, questionId, optionId}
IdentificationController -> IdentificationService : processAnswer(params)
IdentificationService -> PG : SELECT answer_tree FROM test_answer_tree WHERE promotion_id=promoId
PG --> IdentificationService : tree

IdentificationService --> IdentificationController : {nextQuestionId|null, resultSegmentId|null}
IdentificationController --> User : response

@enduml
```

## Админка Акций

Админ создает акцию в статусе NOT_READY. Требования для READY_TO_START: сегменты, цены, идентификация.

`POST /admin/promotions` - Создание акции

```
@startuml
actor Admin

Admin -> PromotionAdminController : POST /admin/promotions {name, description, theme, date_from, date_to, identification_mode, pricing_model, slot_count, min_discount, max_discount, stop_factors: [string]}
PromotionAdminController -> PromotionService : createPromotion(params)
PromotionService -> PG : INSERT INTO promotion
PG --> PromotionService : id

PromotionService -> SegmentService : createDefaultSegments(id, theme)  // Опционально генерировать по теме
SegmentService -> PG : INSERT INTO segment (...)
PG --> SegmentService

PromotionService -> PromotionAdminController : {id, status:'NOT_READY'}
PromotionAdminController --> Admin : promo

@enduml
```

`GET /admin/promotions/{id}` - Получение акции

```
@startuml
actor Admin

Admin -> PromotionAdminController : GET /admin/promotions/{id}
PromotionAdminController -> PromotionService : getPromotion(id)
PromotionService -> PG : SELECT FROM promotion
PG --> PromotionService : promo

PromotionService -> SegmentService : getSegmentsByPromo()
SegmentService -> PG : SELECT FROM segment (...)
PG --> SegmentService

PromotionService -> IdentificationService : getTestByPromo()
IdentificationService -> PG : SELECT questions/options/tree FROM test_* (...)
PG --> IdentificationService

PromotionService -> PromotionAdminController : {id, name, description, theme, status, dates, identification_mode, pricing_model, slot_count, min_discount, max_discount, stop_factors, segments:[{id,name,category_name,order_index}], fixed_prices?: {[position]: number}, test?: {questions:[], answerTree:[]}}
PromotionAdminController --> Admin : promo

@enduml
```

`PATCH /admin/promotions/{id}` - Обновление акции

```
@startuml
actor Admin

Admin -> PromotionAdminController : PATCH /admin/promotions/{id} {partial params}
PromotionAdminController -> PromotionService : updatePromotion(params)
PromotionService -> PG : UPDATE promotion
PG --> PromotionService

PromotionService -> SegmentService : updateSegmentsIfNeeded()
SegmentService -> PG : UPDATE segment
PG --> SegmentService

PromotionAdminController --> Admin : success

@enduml
```

`DELETE /admin/promotions/{id}` - Удаление акции

```
@startuml
actor Admin

Admin -> PromotionAdminController : DELETE /admin/promotions/{id}
PromotionAdminController -> PromotionService : deletePromotion(id)
PromotionService -> PG : UPDATE promotion SET deleted_at ...
PG --> PromotionService

PromotionAdminController --> Admin : success

@enduml
```

`POST /admin/promotions/{id}/segments/generate` - Генерация сегментов по теме (AI)

```
@startuml
actor Admin

Admin -> SegmentAdminController : POST /admin/promotions/{id}/segments/generate {use_theme:boolean, limit?:number}
SegmentAdminController -> AIService : generateSegments(theme, limit)
AIService --> SegmentAdminController : segments

SegmentAdminController -> SegmentService : createSegments(segments)
SegmentService -> PG : INSERT INTO segment (...)
PG --> SegmentService

SegmentAdminController --> Admin : {segments:[{id,name,category_name}]}

@enduml
```

`POST /admin/promotions/{id}/segments` - Добавление сегмента

```
@startuml
actor Admin

Admin -> SegmentAdminController : POST /admin/promotions/{id}/segments {name, category_name, order_index?}
SegmentAdminController -> SegmentService : createSegment(params)
SegmentService -> PG : INSERT INTO segment
PG --> SegmentService : id

SegmentAdminController --> Admin : {id, name, category_name}

@enduml
```

Другие CRUD для сегментов аналогично (PATCH/DELETE).

`POST /admin/promotions/{id}/segments/shuffle-categories` - Перемешать категории сегментов

```
@startuml
actor Admin

Admin -> SegmentAdminController : POST /admin/promotions/{id}/segments/shuffle-categories
SegmentAdminController -> SegmentService : shuffleCategories(promoId)
SegmentService -> PG : UPDATE segment SET category_name = shuffled
PG --> SegmentService

SegmentAdminController --> Admin : success

@enduml
```

`PUT /admin/promotions/{id}/fixed-prices` - Установка цен для фиксированной модели

```
@startuml
actor Admin

Admin -> PromotionAdminController : PUT /admin/promotions/{id}/fixed-prices {prices: [{position:int, price:int}]}
PromotionAdminController -> PromotionService : setFixedPrices(params)
PromotionService -> PG : UPDATE promotion SET fixed_prices = jsonb (или отдельная таблица)
PG --> PromotionService

PromotionAdminController --> Admin : success

@enduml
```

`PUT /admin/promotions/{id}/status` - Изменение статуса

```
@startuml
actor Admin

Admin -> PromotionAdminController : PUT /admin/promotions/{id}/status {status}
PromotionAdminController -> PromotionService : changeStatus(params)
PromotionService -> PG : UPDATE promotion SET status=...
PG --> PromotionService

PromotionAdminController --> Admin : success

@enduml
```

`POST /admin/promotions/{id}/test/generate` - Генерация теста (AI)

```
@startuml
actor Admin

Admin -> IdentificationAdminController : POST /admin/promotions/{id}/test/generate {type: 'questions'|'answer_tree'}
IdentificationAdminController -> AIService : generateTest(theme, type)
AIService --> IdentificationAdminController : test

IdentificationAdminController -> IdentificationService : saveTest(test)
IdentificationService -> PG : INSERT INTO test_question/test_option/test_answer_tree
PG --> IdentificationService

IdentificationAdminController --> Admin : {questions?[], answerTree?[]}

@enduml
```

`POST /admin/promotions/{id}/test/questions` - Ручная установка вопросов

Аналогично генерации, но с body {questions:[{text, options:[{text,value}]}]}

`POST /admin/promotions/{id}/test/answer-tree` - Ручная установка дерева ответов

Аналогично, body {nodes:[{node_id,parent_node_id,label,value}]}

`POST /ai/get-text` - Генерация текста (расширено для сегментов)

```
@startuml
actor Admin

Admin -> AIController : POST /ai/get-text {params, segmentId?}
AIController -> AIService : generateText(params)
AIService --> AIController : text

AIController -> SegmentService : updateSegmentText(text, segmentId)
SegmentService -> PG : UPDATE segment SET text=... (или отдельная таблица segment_text)
PG --> SegmentService

AIController --> Admin : text

@enduml
```

`POST /horoscope/products` - Ручная установка товаров (расширено на segments/slots)

```
@startuml
actor Admin

Admin -> PromotionAdminController : POST /horoscope/products {params, segmentId, slotId?}
PromotionAdminController -> SlotService : setProduct(params)

SlotService -> PG : UPDATE slot SET product_id=..., status='occupied'

PromotionAdminController --> Admin : success

@enduml
```

`GET /admin/promotions/{id}/moderation/applications` - Список заявок на модерацию

```
@startuml
actor Admin

Admin -> ModerationController : GET /admin/promotions/{id}/moderation/applications {status?}
ModerationController -> ModerationService : getApplications(params)
ModerationService -> PG : SELECT FROM moderation WHERE promotion_id=... AND status=?
PG --> ModerationService : applications

ModerationService --> ModerationController : [{id, sellerId, segmentId, slotId, productName, price, discount, stop_factors, status}]
ModerationController --> Admin : applications

@enduml
```

`POST /admin/moderation/{applicationId}/approve` - Одобрение

```
@startuml
actor Admin

Admin -> ModerationController : POST /admin/moderation/{applicationId}/approve
ModerationController -> ModerationService : approve(applicationId)
ModerationService -> PG : UPDATE moderation SET status='approved'; UPDATE slot SET status='occupied', product_id=...
PG --> ModerationService

ModerationController --> Admin : success

@enduml
```

`POST /admin/moderation/{applicationId}/reject` - Отказ

Аналогично approve, body {reason?}, UPDATE status='rejected', slot='available'

## ЛК Селлера (Seller)

`GET /products/list-by` - Список продуктов селлера (без изменений)

`GET /horoscope/list-pending-by-category-id/` - Получить доступные акции (расширено)

Теперь `GET /seller/actions` (контракт выше)

`GET /seller/bets/list` - Список ставок/заявок селлера (расширено на slots/applications)

```
@startuml
actor Seller

Seller -> SellerSlotController : GET /seller/bets/list (params)
SellerSlotController -> SlotService : getSellerSlots()

SlotService -> PG : SELECT FROM slot/bet/moderation WHERE seller_id=?
PG --> SlotService : items

SlotService --> SellerSlotController : items
SellerSlotController --> Seller : [{id, promotionId, segmentId, slotId, bet?, price?, status, productName}]

@enduml
```

`POST /seller/bets/make` - Поставить ставку/купить слот (расширено)

```
@startuml
actor Seller

Seller -> SellerSlotController : POST /seller/bets/make {slotId, amount? (for auction), product:{name,price,discount,image?} (for fixed)}
SellerSlotController -> SlotService : participate(params)

alt auction
SlotService -> PG : INSERT INTO bet
PG --> SlotService
SlotService -> KafkaProducer : publish(auction_changed)
end

alt fixed
SlotService -> PG : UPDATE slot SET status='pending', seller_id=..., product_id=...; INSERT INTO moderation
end

SlotService --> SellerSlotController : ok
SellerSlotController --> Seller : success

@enduml
```

`POST /seller/bets/remove` - Отменить ставку/заявку

```
@startuml
actor Seller

Seller -> SellerSlotController : POST /seller/bets/remove {slotId}
SellerSlotController -> SlotService : cancel(params)

SlotService -> PG : UPDATE bet/moderation/slot SET deleted_at/status='available'...
PG --> SlotService

SlotService --> SellerSlotController : ok
SellerSlotController --> Seller : success

@enduml
```

## AI Эндпоинты

`POST /ai/themes` - Генерация тем

```
@startuml
actor Admin

Admin -> AIController : POST /ai/themes
AIController -> AIService : generateThemes()
AIService --> AIController : themes

AIController --> Admin : {themes:[{value,label}]}

@enduml
```

`POST /ai/segments` - Генерация сегментов по теме

```
@startuml
actor Admin

Admin -> AIController : POST /ai/segments {theme, limit?}
AIController -> AIService : generateSegments(params)
AIService --> AIController : segments

AIController --> Admin : {segments:[{name, category_name?}]}

@enduml
```

`POST /ai/questions` - Генерация вопросов

```
@startuml
actor Admin

Admin -> AIController : POST /ai/questions {theme}
AIController -> AIService : generateQuestions(params)
AIService --> AIController : questions

AIController --> Admin : {questions:[{text, options:[{text,value}]}]}

@enduml
```

`POST /ai/answer-tree` - Генерация дерева ответов

```
@startuml
actor Admin

Admin -> AIController : POST /ai/answer-tree {theme}
AIController -> AIService : generateAnswerTree(params)
AIService --> AIController : nodes

AIController --> Admin : {nodes:[{node_id,parent_node_id,label,value}]}

@enduml
```

### Актуализированный Файл: 20251108161617_init.sql

```
-- +goose Up
-- +goose StatementBegin
create schema if not exists app;

create table app.promotion (
    id serial primary key,
    name text not null,
    description text not null,
    theme text not null,  -- e.g., 'zodiac', 'harry-potter'
    date_from timestamptz not null,
    date_to timestamptz not null,
    status text not null check (status in ('NOT_READY', 'READY_TO_START', 'RUNNING', 'PAUSED', 'COMPLETED')),
    identification_mode text not null check (identification_mode in ('questions', 'user_profile')),
    pricing_model text not null check (pricing_model in ('auction', 'fixed')),
    slot_count int not null default 10,
    min_discount int,
    max_discount int,
    stop_factors jsonb,  -- e.g., ["incorrect_description", "violation_rules"]
    created_at timestamptz not null,
    updated_at timestamptz not null,
    deleted_at timestamptz
);

create index idx_promotion_status on app.promotion(status);

create table app.segment (
    id serial primary key,
    promotion_id int references app.promotion(id) not null,
    name text not null,
    category_id int,
    category_name text,
    color text,  -- optional for UI
    order_index int not null default 0,
    created_at timestamptz not null,
    updated_at timestamptz not null
);

create index idx_segment_promotion on app.segment(promotion_id);

create table app.test_question (
    id serial primary key,
    promotion_id int references app.promotion(id) not null,
    text text not null,
    order_index int not null default 0,
    created_at timestamptz not null,
    updated_at timestamptz not null
);

create index idx_test_question_promotion on app.test_question(promotion_id);

create table app.test_option (
    id serial primary key,
    question_id int references app.test_question(id) not null,
    text text not null,
    value text not null,  -- machine value
    order_index int not null default 0,
    created_at timestamptz not null,
    updated_at timestamptz not null
);

create index idx_test_option_question on app.test_option(question_id);

create table app.test_answer_tree (
    id serial primary key,
    promotion_id int references app.promotion(id) not null,
    node_id uuid not null,
    parent_node_id uuid,
    label text not null,
    value text not null,
    created_at timestamptz not null
);

create index idx_test_answer_tree_promotion on app.test_answer_tree(promotion_id);

create table app.slot (
    id serial primary key,
    promotion_id int references app.promotion(id) not null,
    segment_id int references app.segment(id) not null,
    position int not null,
    pricing_type text not null check (pricing_type in ('auction', 'fixed')),
    price bigint,  -- for fixed
    auction_id int,  -- FK app.auction(id) if auction
    status text not null check (status in ('available', 'occupied', 'pending', 'moderation', 'rejected')),
    seller_id int,
    product_id int references app.product(id),
    created_at timestamptz not null,
    updated_at timestamptz not null
);

create index idx_slot_segment on app.slot(segment_id);
create index idx_slot_status on app.slot(status);

create table app.moderation (
    id serial primary key,
    promotion_id int references app.promotion(id) not null,
    segment_id int references app.segment(id) not null,
    slot_id int references app.slot(id) not null,
    seller_id int not null,
    product_id int references app.product(id) not null,
    discount int not null,
    stop_factors jsonb,
    status text not null check (status in ('pending', 'approved', 'rejected')),
    created_at timestamptz not null,
    updated_at timestamptz not null,
    moderated_at timestamptz,
    moderator_id int
);

create index idx_moderation_promotion on app.moderation(promotion_id);
create index idx_moderation_status on app.moderation(status);

-- Существующие таблицы (с изменениями)
create table app.zodiac (  -- Оставляем для темы 'zodiac'
    id serial primary key,
    name text not null
);

create table app.horoscope (  -- Оставляем для совместимости с 'zodiac'; в будущем мигрировать на segment_text
    id serial primary key,
    promotion_id int references app.promotion(id) not null,
    zodiac_id int references app.zodiac(id) not null,
    created_at timestamptz not null,
    text text not null,
    category_id int not null
);

create table app.product (
    id serial primary key,
    nm_id bigint not null,
    category_id int not null,
    category_name text not null,
    name text not null,
    image text,
    price bigint not null constraint price_check check ( price > 0 ),
    created_at timestamptz not null,
    updated_at timestamptz not null,
    deleted_at timestamptz
);

create table app.horoscope_product(  -- Оставляем для совместимости; в будущем slot.product_id
    horoscope_id int references app.horoscope(id) not null ,
    product_id int references app.product(id) not null
);

create table app.auction (
    id serial primary key,
    date_from timestamptz not null,
    date_to timestamptz not null,
    created_at timestamptz not null,
    updated_at timestamptz not null,
    deleted_at timestamptz,
    slot_id int references app.slot(id) not null,  -- Изменено: связь с slot вместо horoscope_id+position
    min_price bigint not null,
    bid_step bigint not null
);

create table app.bet (
    id serial primary key,
    auction_id int references app.auction(id) not null,
    product_id int references app.product(id) not null,
    bet bigint not null constraint bet_check check ( bet > 0 ),
    created_at timestamptz not null,
    deleted_at timestamptz
);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
SELECT 'down SQL query';
-- +goose StatementEnd
```